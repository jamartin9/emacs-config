<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>java</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="org-default.css" />
</head>
<body>
<div id="content" class="container">
<nav aria-label="breadcrumb" style="--pico-nav-breadcrumb-divider: '|';" id="org8c48fdd">
<ul class="org-ul">
<li><a href="index.html#ID-3a34d6d7-6f37-4573-b20e-3c93894e54ac">üè†</a></li>
<li><a href="site_map.html#ID-30ea5e38-9b41-4bcd-8631-76821e93e294">üó∫</a></li>
</ul>
</nav>
<div id="outline-container-org96088e2" class="outline-2">
<h2 id="org96088e2">java</h2>
<div class="outline-text-2" id="text-org96088e2">
<ul class="org-ul">
<li><code>alias javaListProps="java -server -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions --version"</code></li>
<li><code>alias javaToolOptions="export JAVA_TOOL_OPTIONS='-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heapdump.hprof -XX:StartFlightRecording=disk=true,dumponexit=true,filename=recording.jfr,maxsize=1024m,maxage=1d,settings=profile,path-to-gc-roots=true -Xlog:gc:gc.log:utctime,uptime,tid,level:filecount=10,filesize=128m -XX:NativeMemoryTracking=detail -XX:+PreserveFramePointer'"</code></li>
<li><code>-XX:+UseTransparentHugePages -XX:+AlwaysPreTouch</code></li>
<li><code>-XX:+PerfDisableSharedMem</code></li>
<li><code>-XX:+UseStringDeduplication</code></li>
<li>ZGC takes ~3% of heap</li>
<li>6 months release</li>
<li>3 year lts release</li>
<li>espresso for java on java (graalvm)
<ul class="org-ul">
<li>supports hot reload</li>
</ul></li>
<li>microprofile for javaee</li>
<li>sealed classes</li>
<li>records</li>
<li>babylon
<ul class="org-ul">
<li>trition kernels</li>
<li>bytecode transformations and auto diff
<ul class="org-ul">
<li><a href="https://openjdk.org/projects/babylon/articles/auto-diff">https://openjdk.org/projects/babylon/articles/auto-diff</a></li>
</ul></li>
</ul></li>
<li>virtual threads with loom</li>
<li>vector API and FFI with panama</li>
<li>valhalla for value types (objects without identity)</li>
<li><code>jcmd &lt;pid&gt; JFR.view</code> in 21+</li>
<li>AutoCloseable interface for try with resources</li>
</ul>
</div>
<div id="outline-container-org3fcb0ca" class="outline-3">
<h3 id="org3fcb0ca">spark jetty websocket wrapper</h3>
<div class="outline-text-3" id="text-org3fcb0ca">
<div class="org-src-container">
<pre class="src src-java" id="org6f52893">import io.reactivex.*;
import org.eclipse.jetty.websocket.api.Session;
import wrapper.SocketWrapper;
import static spark.Spark.*;
import java.util.Map;
import java.util.concurrent.TimeUnit;
public class Main{
    public static void main(String [] args) throws InterruptedException {
        // socket server
        webSocket("/echo", SocketWrapper.class);
        init();
        // poll connections and print out all messages async
        Map&lt;Session, Flowable&lt;String&gt;&gt; sessions = SocketWrapper.getConnections();
        while(true){
            int socketcount = 0;
            for(Session session: sessions.keySet()){
                socketcount++;
                int mycount = socketcount;
                // get the flowable of messages
                Flowable&lt;String&gt; source_one = sessions.get(session);
                // background thread
                //source_one.subscribeOn(Schedulers.newThread()).subscribe((String s) -&gt; {
                //        System.out.println("Subscriber "+mycount+" "+s);
                //});
                source_one.subscribe((String s) -&gt; {
                    System.out.println("Subscriber "+mycount+" "+s);
                });
            }
            Thread.sleep(TimeUnit.MILLISECONDS.toMillis(10));
        }
    }
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-java" id="org044b2bb">package wrapper;
import io.reactivex.BackpressureStrategy;
import io.reactivex.Flowable;
import io.reactivex.FlowableEmitter;
import org.eclipse.jetty.websocket.api.*;
import org.eclipse.jetty.websocket.api.annotations.*;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
@WebSocket
public class SocketWrapper {
    private static final Map&lt;Session, Flowable&lt;String&gt;&gt; sessions = new ConcurrentHashMap&lt;&gt;();
    private static final Map&lt;Session, Queue&lt;String&gt;&gt; buffers = new ConcurrentHashMap&lt;&gt;();
    public static Map&lt;Session, Flowable&lt;String&gt;&gt; getConnections(){
        return sessions;
    }
    @OnWebSocketConnect
    public void connected(Session session) {
        // create buffer
        buffers.put(session, new ConcurrentLinkedQueue&lt;&gt;());
        // flowable to consume buffer
        Flowable&lt;String&gt; flow = Flowable.create(
                // called on each subscriptions, no history
                (FlowableEmitter&lt;String&gt; emitter) -&gt; {
                    // get the queue of incoming messages
                    Queue&lt;String&gt; buffer = buffers.get(session);
                    // poll while the session is active
                    while(sessions.containsKey(session)) {
                        // user hipster
                        // db datum
                        // pass roflcopter
                        // port 5432
                        // address 127.0.0.1
                        //Database db = Database.from("jdbc:postgresql://localhost/datum?user=hipster&amp;password=roflcopter");
                        //Database adb = db.asynchronous();
                        // db results
                        // from sync request publish when done
                        //emitter.onNext(db.select("select * from user").getAs(String.class).toBlocking().single());
                        //emitter.onNext(adb.select("select * from user").getAs(String.class).limit(1).toBlocking().single());
                        // async request
                        // get all off buffer
                        while(!buffer.isEmpty()){
                            //re publish
                            emitter.onNext(buffer.poll());
                        }
                        Thread.sleep(1);
                    }
                    // session is done
                    emitter.onComplete();
                }, BackpressureStrategy.BUFFER);
        // session with flowable for connections
        sessions.put(session, flow);
    }
    @OnWebSocketClose
    public void closed(Session session, int statusCode, String reason) {
        buffers.get(session).add("Session Closed: "+reason+" Status Code: "+statusCode);
        sessions.remove(session);
        buffers.remove(session);
    }
    @OnWebSocketMessage
    public void message(Session session, String message) throws IOException {
        buffers.get(session).add(message);
        session.getRemote().sendString(message);
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
